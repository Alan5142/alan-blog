---
title: Programaci√≥n orientada a objetos en C
year: 2020
month: 06
day: 24
hour: '22:00'
excerpt: Este post va a ser algo corto y hablar√© del porqu√© de esta p√°gina, principalmente son 3 motivos...
picture: /images/blog/first_post/header.png
---

¬øQu√©?, ¬øprogramaci√≥n orientada a objetos en C?, ¬øes esto posible?, la respuesta es ¬°s√≠, si es posible!, y no es tan complicado como suena, pero requiere de trabajo manual üí™, entonces, repasemos lo que es la programaci√≥n orientada a objetos

> Es un paradigma de programaci√≥n basado en el concepto de "objetos", que contienen datos en la forma de campos (conocidos como atributos o propiedades) y c√≥digo
> en la forma de procedimientos (llamados m√©todos)
<p style="font-size: 0.7em; text-align: right">Tomado de <a href="https://en.wikipedia.org/wiki/Object-oriented_programming#cite_note-1">Wikipedia</a></p>

Ok, pero, ¬øc√≥mo uso la OOP en C?

Antes de empezar, hay muchas formas de hacer esto, en general todas comparten ciertas similitudes, por lo que esta solo es una forma de hacerlo

Entonces, ¬°comencemos!

# Clases
¬øQu√© ser√≠a de un lenguaje orientado a objetos si no tuviera clases?, por eso es lo primero que debemos pensar en implementar.
De hecho, no es t√°n dif√≠cil implementar esto.

Primero, veamos como se crea una clase en C++:
```cpp
class Clase [: [public|protected|private] Clase1, [public|protected|private] Clase2...]
{
[public|protected|private]
};
```
> class y struct en C++ son lo mismo, solo difieren por el tipo de acceso por defecto siendo public en struct y private en class

En C solo tenemos las ``struct``, pero con ellas podemos hacer todo, excepto propiedades privadas y protegidas, ¬øo no?, ¬°si podemos tener propiedades privadas!,
hay muchas formas de hacer esto, algunas que no son tan privadas (por ejemplo, tener un prefijo para indicar que son privadas) o utilizar una estructura que implemente
eso y solo pueda ser accedida desde un lugar privado üôÄ.

Para esto se requiere de algo:
Una estructura que sirva para almacenar las variables privadas y que no pueda ser utilizada en el contexto _p√∫blico_,
para ello vamos a recurrir a utilizar una _forward declaration_ de esta estructura.

> _Forward declaration_ se refiere a declarar un identificador (tipo, variable, constante, funci√≥n) a la que todav√≠a no se le ha dado una definici√≥n completa

Entonces, imaginemos que nuestra clase se llama ``MyClass``, entonces podr√≠amos llamar a nuestra implementaci√≥n de las variables privadas
``MyClassPrivate``, por lo que quedar√≠a de esta forma:
```c
// .h
struct MyClassPrivate;
typedef struct MyClass
{
    // El compilador necesita saber el tama√±o, en este caso el tama√±o de un apuntador
    // Si no es un apuntador, el compilador no sabe el tama√±o y pues no nos dejar√° compilar
    struct MyClassPrivate *private;
};
// .c

typedef struct MyClassPrivate
{
    int b;
    int c;
} MyClassPrivate;

// obj->private solo puede ser accedido en este archivo* (hay maneras de saltarse esto, pero no las hablar√© aqu√≠)
```

# Constructores y destructores

> Un constructor es un m√©todo que se encarga de inicializar un objeto de cierta clase.

Los constructores son una de las partes m√°s importantes, pues permiten la inicializaci√≥n de los objetos a un estado
en el que sea conveniente para el programa, por ejemplo, imaginemos una clase llamada "TcpConnection" y un constructor que tome
una direcci√≥n ip y un puerto para conectarse, aqu√≠ se puede establecer esa parte de inicializar la conexi√≥n a un estado en el
que realmente este conectado a "ip:puerto"

En C++ contamos con distintos tipos de ctor, todos tienen la tarea de inicializar un objeto de una clase espec√≠fica.
* ``Class::Class()`` -> constructor vac√≠o
* ``Class:Class(const Class &obj)`` -> constructor copia
* ``Class::Class(Class &&obj)`` -> constructor de movimiento
* ``Class::Class(params...)`` -> constructor con par√°metros

Dicho esto, ¬øc√≥mo utilizamos constructores en C?

Puesto que en C solo tenemos funciones, tenemos que recurrir a ellas para inicializar nuestras instancias,
una forma de hacer esto es de la siguiente manera:
```c
typedef struct Hey
{
    int a;
} Hey;

void Hey_ctor(Hey *self);

// y para usarla
Hey hey;
Hey_ctor(&self);
```

Sencillo, ¬øno?, los dem√°s constructores pueden ser implementador de la misma manera, solo basta con mandarle los par√°metros que necesitemos,
por ejemplo, un constructor que reciba un int quedar√≠a as√≠:
```c
// puesto que en C no existe la sobrecarga de funciones, podemos extender el nombre
void Hey_ctor_i(Hey *self, int param);
```

Oye, ¬øy un destructor?üí•

¬°Pues de la misma manera!, implementamos una funci√≥n que se encargue de realizar esta funci√≥n, veamos el siguiente ejemplo
```c
void Hey_dtor(Hey *self);

// y para usarla
Hey hey;
Hey_ctor(&hey);
// usamos el objeto
Hey_dtor(&hey); // y llamamos al dtor
```

¬°Veamos un ejemplo donde apliquemos clases, ctors y dtor!

```c
// Class.h
struct MyClassPrivate;

typedef struct MyClass
{
    // variables privadas
    struct MyClassPrivate *private_members;

    // variables publicas
    int a;
} MyClass;

void MyClass_ctor(MyClass *self, int b, int c);

int MyClass_get_c(MyClass *self);

void MyClass_dtor(MyClass *self);

// Class.c
#include "class.H"
#include <stdlib.h>

typedef struct MyClassPrivate
{
    int b; // esta variable es privada :D
    int c; // esta tambi√©n
} MyClassPrivate;

void MyClass_ctor(MyClass *self, int b, int c)
{
    self->a = 0;

    self->private_members = malloc(sizeof(MyClassPrivate));

    self->private_members->b = b;
    self->private_members->c = c;
}

int MyClass_get_c(MyClass *self)
{
    return self->private_members->c;
}

void MyClass_dtor(MyClass *self)
{
    // limpiamos los recursos que haya utilizado MyClass
    free(self->private_members);
}
// main.c
#include "class.h"
#include <stdio.h>

int main(void)
{
    MyClass object;
    MyClass_ctor(&object, 3, 25);

    int tmp = object.private_members->b; // oops, error, tipo incompleto
    printf("C vale: %d", MyClass_get_c(&object));

    MyClass_dtor(&object);
}
```
Como se puede ver, no es tan complicado realizar esto, quiz√° un poco repetitivo, sin embargo, hay una cuesti√≥n, espero que la hayas notado ;)

¬°**Malloc** solo para implementar variables privadas! üò±

Calma, que se puede implementar de otra forma, podemos tener un buffer local de memoria del tama√±o que necesitemos para
las variables privadas, o confiar y utilizar una convenci√≥n para las variables privadas (personalmente creo que esto √∫ltimo es lo mejor)
# Herencia

> Es un mecanismo para permitir que una clase X se base en otra clase Y, estableciendo una relaci√≥n "X es subclase de Y"

<blockquote>
    <i class="v-icon mdi mdi-alert" style="color: yellow; font-size: 2em"></i> Opini√≥n personal
    <br>
    <p>Personalmente no soy partidiario de abusar de la herencia, pues creo que puede dar lugar a c√≥digo muy complejo y dif√≠cil de mantener</p>
</blockquote>

La herencia consiste en crear nuevas clases que partan de clases ya existentes, de manera que tienen todas las propiedades y m√©todos de la clase padre; implementar
esto en C tampoco supone dificultad alguna, aunque siendo estrictos, lo implementamos a partir de la composici√≥n
```cpp
struct Object
{
    int x;
    int y;
};

struct 2dBox : public Object
{
    int width;
    int height;
};
```

En C esto se traduce en:
```c
typedef struct
{
    int x;
    int y;
} Object;

typedef struct 2dBox
{
    Object super; // clase base
    int width;
    int height;
};
```

¬øC√≥mo se ve la estructura ``2dBox`` en memoria?, pues de la siguiente manera (sin contar padding, alignment ni tama√±o de los tipos de dato)

![Layout en memoria](/images/blog/oop_c/mem_layout.png)

Con la imagen anterior podemos observar que las propiedades de la clase Object van antes que cualquier propiedad de la clase 2dBox, bien podr√≠amos ponerla en cualquier orden,
pero por cuesti√≥n de est√©tica las pondremos al principio

Hasta aqu√≠ todo bien, as√≠ que la herencia se puede resumir de la siguiente manera
> Para heredar de otras clases tenemos que recurrir a la composici√≥n

A√∫n hay un aspecto que no hemos tocado, ¬°las sobrecarga de m√©todos y los dtor virtuales!

# Polimorfismo

Antes de entrar a esto, voy a explicar que son los apuntadores a funcions, como declarar uno y como usarlos, posteriormente explicar√© lo que es una vtable.

### Apuntadores a funciones

Los apuntadores a funciones (function pointers) son un tipo especial de apuntadores que tienen la caracter√≠stica de apuntar
a una funci√≥n y para llamar a la funci√≥n a la que apuntan, los usamos como si fuera una funci√≥n.

La sintaxis para declarar un apuntador a funci√≥n es la siguiente (lo se, es fea)
```
[tipo de retorno] (*nombre de la variable)(parametros...);
```

Y un uso de estos ser√≠a el siguiente
```c
#include <stdio.h>
int square(int param)
{
    return param * param;
}

int main(void)
{
    int (*my_func_ptr)(int) = square; // lo asignamos a la funci√≥n
    // tambi√©n podemos asignarlo aqu√≠ de la siguiente manera:
    // my_func_ptr = &square;

    printf("%d", my_func_ptr(8));
}
```

Lo bueno es que podemos utilizar typedefs para hacerlos m√°s bonitos c:
```c
#include <math.h>
typedef double (*FuncPtr)(double);

int main(void)
{
    FuncPtr fptr = sin; // Ya no esta feo :D
}
```

Los apuntadores a funciones son muy √∫tiles cuando se desean implementar callbacks o personalizar el comportamiento de una funci√≥n (por ejemplo, [qsort](https://en.cppreference.com/w/c/algorithm/qsort))

### Virtual method table
Tambi√©n llamada vtable, es una forma de permitir las funciones virtuales (_dynamic dispatch_), es muy utilizada en muchos lenguajes,
de manera sencilla, consiste en una tabla que contiene apuntadores a los m√©todos que se deben llamar para determinada instancia, de esta manera
se sabe cual funci√≥n virtual llamar.


Es importante mencionar que una vtable *es la misma* para objetos del mismo tipo, por lo que incluso se puede compartir.

Veamos como implementar una vtable en C

```c
// .h
typedef struct
{
    int health;
} Player;

typedef struct
{
    void (*damage_player)(Player *player); // funci√≥n que puede ser cambiada por cualquier clase hija
} EnemyVTable;

typedef struct
{
    EnemyVTable const *vtable_ptr; // la vtable
} Enemy;

typedef struct
{
    Enemy super;
    int health;
} Orc;

typedef struct
{
    Enemy super;
    int health;
} Dragon;

void Enemy_ctor(Enemy *self);
void Player_ctor(Player *self;
void Orc_ctor(Orc *self);
void Dragon_ctor(Dragon *self);

static inline enemy_damage_player(Enemy *self, Player *player)
{
    (*self->vtable_ptr->damage_player)(player);
}

// .c

void orc_damage_player(Enemy *enemy, Player *player)
{
    player->health -= 30;
}

void dragon_damage_player(Enemy *enemy, Player *player)
{
    player->health -= 500;
}

void Player_ctor(Player *self)
{
    self->health = 3000;
}

void Enemy_ctor(Enemy *self)
{
    static EnemyVTable const vtbl = {
        NULL // No tiene una implementaci√≥n
    };
}

void Orc_ctor(Orc *self)
{
    static EnemyVTable const vtbl = {
        &orc_damage_player
    };
    // Llamamos al ctor de la clase base
    Enemy_ctor(&self->super);

    self->super.vtable_ptr = vtbl;
    self->health = 1000;
}

void Dragon_ctor(Dragon *self)
{
    static EnemyVTable const vtbl = {
            &dragon_damage_player
    };

    // Llamamos al ctor de la clase base
    Enemy_ctor(&self->super);

    self->super.vtable_ptr = vtbl;
    self->health = 10000;
}
```

Vamos a explicar parte por parte, empezando con la declaraci√≥n de la estructura EnemyVTable:
```c

```

¬°Ahora si!, vamos a probarlo todo

```c

int main(void)
{
    Player player;
    Player_ctor(&player);
    
    Orc orc;
    Orc_ctor(&orc);

    Dragon dragon;
    Dragon_ctor(&dragon);
    
    enemy_damage_player(&orc.super, &player); // nuestra salud baja a 2500
    enemy_damage_player(&dragon.super, &player); // nuestra salud baja a 2470
}
```

¬°Listo!, hemos implementado _dynamic dispatch_, ¬øno es asombroso?, sin embargo, como esta ahorita, no podemos, por ejemplo, acceder a propiedades de la estructura ``Dragon`` dentro ``dragon_damage_player``,
sin embargo, si es posible hacerlo _pero no de manera sencilla_, pues tenemos que movernos en la memoria para ello (en este caso no hay tanto problema, simplemente hacemos un cast a ``Dragon``), por ejemplo, 
